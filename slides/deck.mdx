import { Image, Notes } from "mdx-deck";
import { dark } from "mdx-deck/themes";
import Layout from "./layout";
import { CodeSurfer } from "code-surfer";
import codeSurfer from "prism-react-renderer/themes/nightOwl";
// import "prismjs/components/prism-haskell";
export { components } from "mdx-deck-code-surfer";
export const theme = {
  ...dark,
  codeSurfer,
  monospace: '"Dank Mono", "Fira Code", Consolas, "Roboto Mono", monospace',
  colors: {
    text: "rgb(214, 222, 235)",
    code: "rgb(130, 170, 255)",
    link: "rgb(128, 203, 196)",
    background: "rgb(1, 22, 39)",
  },
};

<Image src={require("file-loader!./mu-graphql.jpg")} />

---

export default Layout;

# mu-haskell + GraphQL = ðŸ’œ

---

export default Layout;

```graphql This is our source of truth ðŸ§¼
type Book {
  title: String!
  author: Author!
}

type Author {
  name: String!
  books: [Book!]!
}

type Query {
  authors: [Author!]!
  books: [Book!]!
}
```

---

export default Layout;

```haskell Our first GraphQL Server! ðŸš€
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -fno-warn-partial-type-signatures #-}

module Main where

import Data.List (find)
import Data.Proxy
import Data.Text (Text)
import Mu.GraphQL.Quasi
import Mu.GraphQL.Server
import Mu.Schema
import Mu.Server

graphql "ServiceDefinition" "schema.graphql"

-- GraphQL App

main :: IO ()
main = do
  putStrLn "starting GraphQL server on port 8080"
  runGraphQLAppQuery 8080 server (Proxy @"Query")

type ServiceMapping =
  '[ "Book" ':-> (Text, Text),
     "Author" ':-> Text
   ]

library :: [(Text, [Text])]
library =
  [ ("Robert Louis Stevenson", ["Treasure Island", "Strange Case of Dr Jekyll and Mr Hyde"]),
    ("Immanuel Kant", ["Critique of Pure Reason"]),
    ("Michael Ende", ["The Neverending Story", "Momo"])
  ]

server :: forall m. MonadServer m => ServerT ServiceMapping ServiceDefinition m _
server =
  resolver
    ( object @"Book"
        ( field @"title" bookTitle,
          field @"author" bookAuthor
        ),
      object @"Author"
        ( field @"name" authorName,
          field @"books" authorBooks
        ),
      object @"Query"
        ( method @"authors" allAuthors,
          method @"books" allBooks
        )
    )
  where
    bookTitle :: (Text, Text) -> m Text
    bookTitle (_, title) = pure title
    bookAuthor :: (Text, Text) -> m Text
    bookAuthor (auth, _) = pure auth
    authorName :: Text -> m Text
    authorName = pure
    authorBooks :: Text -> m [(Text, Text)]
    authorBooks name = pure $ (name,) <$> maybe [] snd (find ((== name) . fst) library)
    allAuthors :: m [Text]
    allAuthors = pure $ fst <$> library
    allBooks :: m [(Text, Text)]
    allBooks = pure [(author, title) | (author, books) <- library, title <- books]
----
* > ðŸ’œ
1:10 > Just a few language pragmas!
11 > Do this if you are a warning freak
15:21 > Some imports here and there
23 > This is were the magic happens! âœ¨
25:30 > Our main call
31:35 > Service mapping
37:42 > Example hardcoded library
44:59 > Server code
44 > Partial type signature!
60:72 > Helpers
* > That is all! ðŸŽ‰
```

---

export default Layout;

> Demo time!?

---

export default Layout;

# Thanks! ðŸ˜¸
